<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Plinko Furras</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0f14; color:#e9eef5;
      display:flex; flex-direction:column; min-height:100vh;
      overscroll-behavior: none;
    }
    header{
      padding:14px 16px; border-bottom:1px solid #1b2633;
      display:flex; align-items:center; gap:14px; flex-wrap:wrap;
    }
    header .group{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    input[type="number"], textarea{
      padding:8px 10px; border:1px solid #243447; border-radius:10px;
      background:#0f1620; color:#e9eef5; outline:none;
      font-family: inherit;
      font-size:16px; /* evita zoom autom√°tico no iOS */
    }
    input[type="number"]{ width:92px; }
    label{ color:#cfe0f7; font-size:13px; }
    button{
      padding:9px 12px; border:1px solid #2a3c52; border-radius:12px;
      background:#101a26; color:#e9eef5; cursor:pointer;
      font-size:16px;
    }
    button:hover{ background:#132033; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .hint{ color:#b7c3d4; font-size:13px; }
    main{
      display:grid; grid-template-columns: 1fr 360px; gap:12px;
      padding:12px; flex:1;
    }
    .panel{
      border:1px solid #1b2633; border-radius:14px; background:#0f1620;
      overflow:hidden;
    }
    #canvasWrap{ position:relative; }
    canvas{
      width:100%; height:100%; display:block;
      background: radial-gradient(1200px 600px at 50% 15%, #0f2034, #070b10);
    }
    .side{ padding:12px; display:flex; flex-direction:column; gap:12px; }
    .card{
      border:1px solid #1b2633; border-radius:14px; background:#0b111a;
      padding:12px;
    }
    h3{ margin:0 0 8px 0; font-size:14px; color:#cfe0f7; }
    .small{ font-size:12px; color:#b7c3d4; line-height:1.35; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    ol{ margin:0; padding-left:20px; }
    li{ margin:6px 0; }
    .badge{
      display:inline-block; min-width:22px; padding:2px 8px; border-radius:999px;
      border:1px solid #2a3c52; background:#0f1620; margin-left:8px; font-size:12px; color:#b7c3d4;
    }
    textarea{
      width:100%;
      min-height: 220px;
      resize: vertical;
      line-height: 1.35;
      white-space: pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:16px;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      textarea{ min-height: 180px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <strong>ü¶ù Plinko Furras</strong>
      <span class="hint">Cole nomes e inicie.</span>
    </div>

    <div class="group" style="margin-left:auto;">
      <label for="players">Jogadores:</label>
      <input id="players" type="number" min="2" max="20" value="8" />

      <label for="heightPx">Altura (px):</label>
      <input id="heightPx" type="number" min="1200" max="8000" value="3600" />

      <button id="startBtn">Iniciar</button>
      <button id="resetBtn">Resetar</button>
      <button id="pauseBtn" disabled>Pausar</button>
    </div>
  </header>

  <main>
    <div class="panel" id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="panel side">
      <div class="card">
        <div class="row">
          <h3>Lista de nomes (1 por linha)</h3>
          <span class="small">Ctrl+V</span>
        </div>
        <textarea id="namesList" placeholder="Cole aqui (um por linha), por exemplo:
Ana
Bruno
Carla
Diego"></textarea>
        <div class="small" style="margin-top:10px;">
          O jogo usa automaticamente a <strong>quantidade de linhas</strong> como n√∫mero de jogadores (m√≠n. 2, m√°x. 20).
          Se faltar nome (ex.: s√≥ 1), completa com ‚ÄúJogador X‚Äù. Se sobrar (mais de 20), usa apenas os 20 primeiros.
        </div>
      </div>

      <div class="card">
        <div class="row">
          <h3>Ordem de chegada (ranking)</h3>
          <span class="small">linha de chegada no final</span>
        </div>
        <ol id="ranking"></ol>
      </div>

      <div class="card">
        <h3>Notas</h3>
        <div class="small">
          Laterais com rampas triangulares (&lt; e &gt;), colis√£o por segmento. P√°s no in√≠cio giram por impacto das bolas (sem motor).
        </div>
      </div>
    </div>
  </main>

<script>
(() => {
  // =========================
  // MUNDO FIXO (n√£o depende do tamanho da tela)
  // =========================
  const SIM_W = 900;

  // Rampas laterais em formato "<" e ">"
  const WALL_PAD = 14;
  const RAMP_INSET_MIN = 90;
  const RAMP_INSET_MAX = 170;

  // ======== F√çSICA ========
  const GRAVITY = 1500;      // px/s^2
  const AIR_DRAG = 0.995;
  const BOUNCE = 0.80;

  const PEG_RADIUS = 6;
  const BALL_RADIUS = 14;
  const FINISH_BAND = 64;

  // Mais aleat√≥rio sem instabilidade
  const RANDOM_KICK = 160;
  const SIDE_NOISE = 35;

  // Anti-stuck
  const UNSTUCK_TIME = 0.22;
  const UNSTUCK_SPEED = 55;
  const UNSTUCK_PUSH_X = 520;
  const UNSTUCK_PUSH_UP = 240;

  // Estabilidade
  const FIXED_DT = 1/120;
  const MAX_ACCUM = 0.12;
  const MAX_STEPS = 12;

  // Limites de velocidade (reduz ‚Äút√∫nel‚Äù e glitches)
  const MAX_VX = 2200;
  const MAX_VY = 4200;

  // ======== P√ÅS GIRAT√ìRIAS ========
  const PADDLE_LEN = 150;
  const PADDLE_THICK = 14;
  const PADDLE_REST = 0.65;
  const PADDLE_DAMP = 1.2;
  const PADDLE_MAX_OMEGA = 16;

  // ======== OTIMIZA√á√ÉO (bucket por altura) ========
  const PEG_BUCKET_H = 120;     // altura de cada ‚Äúfaixa‚Äù para buscar pinos pr√≥ximos
  let pegBuckets = [];          // array de arrays de pinos
  let pegBucketCount = 0;

  // ======== DOM ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const playersInput = document.getElementById('players');
  const heightInput = document.getElementById('heightPx');
  const namesListEl = document.getElementById('namesList');

  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const rankingEl = document.getElementById('ranking');

  // ======== ESTADO ========
  let DPR = 1;
  let CSS_W = 900, CSS_H = 560;
  let SCALE = 1;
  let VIEW_H_WORLD = 560;

  let WORLD_H = 3600;

  let pegs = [];
  let balls = [];
  let paddles = [];

  let running = false;
  let paused = false;
  let animationId = null;

  let finishOrder = [];

  let cameraY = 0;
  let cameraTargetY = 0;

  let lastT = 0;
  let startTime = 0;
  let accumulator = 0;

  // rampas (segmentos)
  let rampInset = 120;
  let leftSeg1, leftSeg2, rightSeg1, rightSeg2;

  // ======== HELPERS ========
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const rand = (a,b) => a + Math.random() * (b - a);
  const now = () => performance.now();

  function distinctColor(i, n){
    const h = (i * (360 / n)) % 360;
    return `hsl(${h} 80% 60%)`;
  }

  function parseNames() {
    return (namesListEl.value || "")
      .split(/\r?\n/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  // ======== AUTO: jogadores = quantidade de nomes (2..20) ========
  function desiredPlayersFromNames() {
    const names = parseNames();
    if (names.length === 0) return null;
    return clamp(names.length, 2, 20);
  }

  function syncPlayersInputFromNames() {
    const n = desiredPlayersFromNames();
    if (n === null) return;
    playersInput.value = n;
  }

  // ======== CANVAS/ESCALA ========
  function fitPanelHeight(){
    const wrap = document.getElementById("canvasWrap");
    const headerH = document.querySelector("header").getBoundingClientRect().height;
    const target = Math.max(420, window.innerHeight - headerH - 24);
    wrap.style.height = target + "px";
  }

  function setCanvasSizeOnly() {
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();

    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    CSS_W = Math.floor(rect.width);
    CSS_H = Math.floor(Math.max(420, rect.height));

    canvas.width  = CSS_W * DPR;
    canvas.height = CSS_H * DPR;
    canvas.style.width = CSS_W + "px";
    canvas.style.height = CSS_H + "px";

    SCALE = CSS_W / SIM_W;
    VIEW_H_WORLD = CSS_H / SCALE;

    cameraY = clamp(cameraY, 0, Math.max(0, WORLD_H - VIEW_H_WORLD));
    cameraTargetY = cameraY;

    draw();
  }

  // ======== GEOMETRIA / COLIS√ÉO ========
  function closestPointOnSegment(px, py, ax, ay, bx, by) {
    const abx = bx - ax, aby = by - ay;
    const apx = px - ax, apy = py - ay;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 === 0 ? 0 : (apx*abx + apy*aby) / ab2;
    t = clamp(t, 0, 1);
    return { x: ax + abx*t, y: ay + aby*t, t };
  }

  function resolveCircleSegment(ball, ax, ay, bx, by, restitution, extraKick=0) {
    const cp = closestPointOnSegment(ball.x, ball.y, ax, ay, bx, by);
    let dx = ball.x - cp.x;
    let dy = ball.y - cp.y;
    let dist = Math.hypot(dx, dy);

    const r = ball.r;
    if (dist >= r || dist === 0) {
      if (dist === 0) { dx = 0; dy = -1; dist = 1; }
      else return false;
    }

    const nx = dx / dist;
    const ny = dy / dist;

    const overlap = r - dist;
    ball.x += nx * overlap;
    ball.y += ny * overlap;

    const vn = ball.vx * nx + ball.vy * ny;
    if (vn < 0) {
      ball.vx -= (1 + restitution) * vn * nx;
      ball.vy -= (1 + restitution) * vn * ny;
      if (extraKick) ball.vx += rand(-extraKick, extraKick) * 0.12;
    }
    return true;
  }

  function rebuildRamps() {
    rampInset = clamp(Math.round(SIM_W * 0.16), RAMP_INSET_MIN, RAMP_INSET_MAX);
    const midY = WORLD_H * 0.5;

    leftSeg1  = { ax: WALL_PAD, ay: 0,        bx: WALL_PAD + rampInset, by: midY };
    leftSeg2  = { ax: WALL_PAD + rampInset, ay: midY, bx: WALL_PAD,     by: WORLD_H };

    rightSeg1 = { ax: SIM_W - WALL_PAD, ay: 0,        bx: SIM_W - WALL_PAD - rampInset, by: midY };
    rightSeg2 = { ax: SIM_W - WALL_PAD - rampInset, ay: midY, bx: SIM_W - WALL_PAD,     by: WORLD_H };
  }

  function resolveSideRamps(ball) {
    resolveCircleSegment(ball, leftSeg1.ax, leftSeg1.ay, leftSeg1.bx, leftSeg1.by, BOUNCE, 0);
    resolveCircleSegment(ball, leftSeg2.ax, leftSeg2.ay, leftSeg2.bx, leftSeg2.by, BOUNCE, 0);
    resolveCircleSegment(ball, rightSeg1.ax, rightSeg1.ay, rightSeg1.bx, rightSeg1.by, BOUNCE, 0);
    resolveCircleSegment(ball, rightSeg2.ax, rightSeg2.ay, rightSeg2.bx, rightSeg2.by, BOUNCE, 0);

    ball.x = clamp(ball.x, -50, SIM_W + 50);
  }

  // ======== TABULEIRO (pinos) ========
  function buildBoard() {
    pegs = [];

    const topMargin = 120;
    const bottomMargin = FINISH_BAND + 120;
    const usableH = WORLD_H - topMargin - bottomMargin;

    const cols = 12;
    const colGap = (SIM_W - 2 * (WALL_PAD + 6)) / cols;

    const rowGapTarget = 54;
    const rows = Math.floor(clamp(usableH / rowGapTarget, 18, 130));
    const rowGap = usableH / rows;

    for (let r = 0; r < rows; r++) {
      const y = topMargin + r * rowGap + 20;
      const offset = (r % 2) * (colGap / 2);

      for (let c = 0; c <= cols; c++) {
        const x = (WALL_PAD + 6) + c * colGap + offset;

        const leftLimit  = WALL_PAD + 14;
        const rightLimit = SIM_W - WALL_PAD - 14;
        if (x < leftLimit || x > rightLimit) continue;

        pegs.push({ x, y, r: PEG_RADIUS });
      }
    }

    // buckets (performance)
    pegBucketCount = Math.ceil(WORLD_H / PEG_BUCKET_H) + 2;
    pegBuckets = Array.from({ length: pegBucketCount }, () => []);
    for (const p of pegs) {
      const idx = clamp(Math.floor(p.y / PEG_BUCKET_H), 0, pegBucketCount - 1);
      pegBuckets[idx].push(p);
    }
  }

  // ======== P√ÅS ========
  function buildPaddles() {
    const baseY = 150;
    paddles = [
      makePaddle(SIM_W * 0.28, baseY,       0.15),
      makePaddle(SIM_W * 0.50, baseY + 40, -0.10),
      makePaddle(SIM_W * 0.72, baseY,       0.10),
    ];
  }

  function makePaddle(x, y, angle) {
    const L = PADDLE_LEN;
    const I = (L*L) / 12;
    return { x, y, len: L, thick: PADDLE_THICK, angle, omega: 0, inertia: I };
  }

  function paddleEndpoints(p) {
    const hx = Math.cos(p.angle) * (p.len / 2);
    const hy = Math.sin(p.angle) * (p.len / 2);
    return { ax: p.x - hx, ay: p.y - hy, bx: p.x + hx, by: p.y + hy };
  }

  function paddleSurfaceVelocity(p, cx, cy) {
    const rx = cx - p.x;
    const ry = cy - p.y;
    return { vx: -p.omega * ry, vy: p.omega * rx };
  }

  function collideBallWithPaddle(ball, p) {
    const ep = paddleEndpoints(p);
    const cp = closestPointOnSegment(ball.x, ball.y, ep.ax, ep.ay, ep.bx, ep.by);

    let dx = ball.x - cp.x;
    let dy = ball.y - cp.y;
    let dist = Math.hypot(dx, dy);

    const effectiveR = ball.r + (p.thick / 2);

    if (dist >= effectiveR || dist === 0) {
      if (dist === 0) { dx = 0; dy = -1; dist = 1; }
      else return false;
    }

    const nx = dx / dist;
    const ny = dy / dist;

    const overlap = effectiveR - dist;
    ball.x += nx * overlap;
    ball.y += ny * overlap;

    const vs = paddleSurfaceVelocity(p, cp.x, cp.y);

    const rvx = ball.vx - vs.vx;
    const rvy = ball.vy - vs.vy;
    const vn = rvx * nx + rvy * ny;

    if (vn < 0) {
      const j = -(1 + PADDLE_REST) * vn;

      ball.vx += j * nx;
      ball.vy += j * ny;

      const rx = cp.x - p.x;
      const ry = cp.y - p.y;
      const torque = rx * (j * ny) - ry * (j * nx);
      p.omega += torque / p.inertia;

      ball.vx += rand(-RANDOM_KICK, RANDOM_KICK) * 0.06;
      p.omega = clamp(p.omega, -PADDLE_MAX_OMEGA, PADDLE_MAX_OMEGA);
    }
    return true;
  }

  function updatePaddles(dt) {
    for (const p of paddles) {
      p.angle += p.omega * dt;
      const damp = Math.max(0, 1 - PADDLE_DAMP * dt);
      p.omega *= damp;

      if (p.angle > Math.PI) p.angle -= 2*Math.PI;
      if (p.angle < -Math.PI) p.angle += 2*Math.PI;
    }
  }

  // ======== BOLAS ========
  function createBalls(n) {
    balls = [];
    finishOrder = [];
    rankingEl.innerHTML = "";

    cameraY = 0;
    cameraTargetY = 0;

    const names = parseNames();
    const topY = 50;
    const gap = (SIM_W - 2 * (WALL_PAD + 10)) / (n + 1);

    for (let i = 0; i < n; i++) {
      const id = i + 1;
      const x = (WALL_PAD + 10) + (i + 1) * gap;
      const name = (names[i] || `Jogador ${id}`).trim() || `Jogador ${id}`;

      balls.push({
        id, name,
        x, y: topY,
        vx: rand(-70, 70),
        vy: rand(-20, 20),
        r: BALL_RADIUS,
        color: distinctColor(i, n),
        finished: false,
        finishT: null,
        lastX: x,
        lastY: topY,
        stuck: 0
      });
    }
  }

  function setControlsEnabled(enabled) {
    playersInput.disabled = !enabled;
    heightInput.disabled = !enabled;
    namesListEl.disabled = !enabled;
  }

  function resetAll() {
    running = false;
    paused = false;

    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    accumulator = 0;

    const nFromNames = desiredPlayersFromNames();
    const n = (nFromNames ?? clamp(parseInt(playersInput.value || "8", 10), 2, 20));
    playersInput.value = n;

    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    rebuildRamps();
    buildPaddles();
    buildBoard();
    createBalls(n);

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    pauseBtn.textContent = "Pausar";
    setControlsEnabled(true);

    cameraY = 0;
    cameraTargetY = 0;

    draw();
  }

  function start() {
    const nFromNames = desiredPlayersFromNames();
    const n = (nFromNames ?? clamp(parseInt(playersInput.value || "8", 10), 2, 20));
    playersInput.value = n;

    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    rebuildRamps();
    buildPaddles();
    buildBoard();
    createBalls(n);

    running = true;
    paused = false;

    accumulator = 0;
    lastT = now();
    startTime = lastT;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = "Pausar";
    setControlsEnabled(false);

    loop();
  }

  function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Continuar" : "Pausar";
    if (!paused) {
      lastT = now();
      loop();
    }
  }

  // ======== COLIS√ïES ========
  function collideBallWithPeg(ball, peg) {
    const dx = ball.x - peg.x;
    const dy = ball.y - peg.y;
    const dist = Math.hypot(dx, dy);
    const minDist = ball.r + peg.r;
    if (dist >= minDist || dist === 0) return;

    const nx = dx / dist;
    const ny = dy / dist;

    const overlap = (minDist - dist);
    ball.x += nx * overlap;
    ball.y += ny * overlap;

    const vn = ball.vx * nx + ball.vy * ny;
    if (vn < 0) {
      ball.vx -= (1 + BOUNCE) * vn * nx;
      ball.vy -= (1 + BOUNCE) * vn * ny;
    }

    ball.vx += rand(-RANDOM_KICK, RANDOM_KICK) * 0.10;
  }

  function collideBalls(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = a.r + b.r;
    if (dist >= minDist || dist === 0) return;

    const nx = dx / dist;
    const ny = dy / dist;
    const overlap = minDist - dist;

    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;

    const dvx = b.vx - a.vx;
    const dvy = b.vy - a.vy;
    const vn = dvx * nx + dvy * ny;
    if (vn > 0) return;

    const impulse = -(1 + 0.62) * vn / 2;
    a.vx -= impulse * nx;
    a.vy -= impulse * ny;
    b.vx += impulse * nx;
    b.vy += impulse * ny;
  }

  // ======== SIMULA√á√ÉO ========
  function physicsStep(dt) {
    updatePaddles(dt);

    const finishLineY = WORLD_H - FINISH_BAND;
    const bottom = WORLD_H - 6;

    for (const b of balls) {
      if (b.finished) continue;

      b.vy += GRAVITY * dt;
      b.vx += rand(-SIDE_NOISE, SIDE_NOISE) * dt;

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      const drag = Math.pow(AIR_DRAG, dt * 60);
      b.vx *= drag;
      b.vy *= drag;

      b.vx = clamp(b.vx, -MAX_VX, MAX_VX);
      b.vy = clamp(b.vy, -MAX_VY, MAX_VY);

      const top = 12 + b.r;
      if (b.y < top) { b.y = top; b.vy = Math.abs(b.vy) * BOUNCE; }

      resolveSideRamps(b);

      for (const p of paddles) collideBallWithPaddle(b, p);

      // pinos pr√≥ximos (bucket)
      const bi = clamp(Math.floor(b.y / PEG_BUCKET_H), 0, pegBucketCount - 1);
      for (let k = bi - 1; k <= bi + 1; k++) {
        if (k < 0 || k >= pegBucketCount) continue;
        const bucket = pegBuckets[k];
        for (let i = 0; i < bucket.length; i++) {
          collideBallWithPeg(b, bucket[i]);
        }
      }

      resolveSideRamps(b);

      if (b.y >= finishLineY - b.r - 2) {
        b.finished = true;
        b.finishT = (now() - startTime) / 1000;

        b.y = finishLineY + FINISH_BAND * 0.5;
        b.vx = 0; b.vy = 0;

        finishOrder.push({ id: b.id, name: b.name, t: b.finishT });
        updateRanking();
        continue;
      }

      if (b.y > bottom - b.r) {
        b.y = bottom - b.r;
        b.vy = -Math.abs(b.vy) * 0.35;
        b.vx *= 0.92;
      }

      // anti-stuck (CORRIGIDO: nada de "bi.vx")
      const speed = Math.hypot(b.vx, b.vy);
      const moved = Math.hypot(b.x - b.lastX, b.y - b.lastY);

      if (speed < UNSTUCK_SPEED && moved < 0.35) {
        b.stuck += dt;
        if (b.stuck > UNSTUCK_TIME) {
          b.vx += rand(-UNSTUCK_PUSH_X, UNSTUCK_PUSH_X);
          b.vy -= rand(0, UNSTUCK_PUSH_UP);

          // clamp correto
          b.vx = clamp(b.vx, -MAX_VX, MAX_VX);
          b.vy = clamp(b.vy, -MAX_VY, MAX_VY);

          b.stuck = 0;
          resolveSideRamps(b);
        }
      } else {
        b.stuck = 0;
      }

      b.lastX = b.x;
      b.lastY = b.y;
    }

    // bola-bola
    for (let i = 0; i < balls.length; i++){
      for (let j = i + 1; j < balls.length; j++){
        if (balls[i].finished || balls[j].finished) continue;
        collideBalls(balls[i], balls[j]);
        resolveSideRamps(balls[i]);
        resolveSideRamps(balls[j]);
      }
    }

    // c√¢mera
    const active = balls.filter(b => !b.finished);
    const yFocus = active.length ? Math.max(...active.map(b => b.y)) : (WORLD_H - FINISH_BAND);
    const desired = clamp(yFocus - VIEW_H_WORLD * 0.35, 0, Math.max(0, WORLD_H - VIEW_H_WORLD));
    cameraTargetY = desired;
    cameraY += (cameraTargetY - cameraY) * 0.12;

    if (finishOrder.length === balls.length) {
      running = false;
      pauseBtn.disabled = true;
      startBtn.disabled = false;
      setControlsEnabled(true);
    }
  }

  // ======== RENDER ========
  function drawRampsWorld() {
    const midY = WORLD_H * 0.5;

    // esquerda
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.beginPath();
    ctx.moveTo(WALL_PAD, 0);
    ctx.lineTo(WALL_PAD + rampInset, midY);
    ctx.lineTo(WALL_PAD, WORLD_H);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(leftSeg1.ax, leftSeg1.ay);
    ctx.lineTo(leftSeg1.bx, leftSeg1.by);
    ctx.lineTo(leftSeg2.bx, leftSeg2.by);
    ctx.stroke();
    ctx.restore();

    // direita
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.beginPath();
    ctx.moveTo(SIM_W - WALL_PAD, 0);
    ctx.lineTo(SIM_W - WALL_PAD - rampInset, midY);
    ctx.lineTo(SIM_W - WALL_PAD, WORLD_H);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(rightSeg1.ax, rightSeg1.ay);
    ctx.lineTo(rightSeg1.bx, rightSeg1.by);
    ctx.lineTo(rightSeg2.bx, rightSeg2.by);
    ctx.stroke();
    ctx.restore();
  }

  function drawFinishWorld() {
    const finishY = WORLD_H - FINISH_BAND;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.07)";
    ctx.fillRect(0, finishY, SIM_W, FINISH_BAND);

    ctx.fillStyle = "rgba(255,255,255,0.40)";
    ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("LINHA DE CHEGADA", 14, finishY + 20);
    ctx.restore();
  }

  function drawPegsWorld() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    for (const p of pegs) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawPaddlesWorld() {
    for (const p of paddles) {
      const ep = paddleEndpoints(p);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.28)";
      ctx.lineWidth = p.thick;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(ep.ax, ep.ay);
      ctx.lineTo(ep.bx, ep.by);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawBallsWorld() {
    for (const b of balls) {
      ctx.save();

      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fillStyle = b.color;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(b.id), b.x, b.y);

      const name = b.name || `Jogador ${b.id}`;
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.strokeText(name, b.x, b.y - b.r - 10);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillText(name, b.x, b.y - b.r - 10);

      ctx.restore();
    }
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const status = running ? (paused ? "PAUSADO" : "RODANDO") : "PRONTO";

    const maxCam = Math.max(0, WORLD_H - VIEW_H_WORLD);
    const pct = maxCam === 0 ? 100 : (cameraY / maxCam * 100);

    ctx.fillText(`Status: ${status}`, 14, 18);
    ctx.fillText(`Jogadores: ${balls.length} | Queda: ${WORLD_H}px | C√¢mera: ${pct.toFixed(0)}%`, 14, 36);
    ctx.restore();
  }

  function draw() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.setTransform(DPR * SCALE, 0, 0, DPR * SCALE, 0, 0);
    ctx.save();
    ctx.translate(0, -cameraY);

    drawFinishWorld();
    drawRampsWorld();
    drawPaddlesWorld();
    drawPegsWorld();
    drawBallsWorld();

    ctx.restore();

    ctx.setTransform(DPR,0,0,DPR,0,0);
    drawHUD();
  }

  function updateRanking() {
    const sorted = [...finishOrder].sort((a,b) => a.t - b.t);
    rankingEl.innerHTML = "";
    for (const item of sorted) {
      const li = document.createElement("li");
      li.textContent = item.name;

      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = `${item.t.toFixed(2)}s`;
      li.appendChild(badge);

      rankingEl.appendChild(li);
    }
  }

  // ======== LOOP ========
  function loop() {
    if (!running || paused) { draw(); return; }

    const t = now();
    let dt = (t - lastT) / 1000;
    lastT = t;

    dt = clamp(dt, 0, MAX_ACCUM);
    accumulator += dt;

    let steps = 0;
    while (accumulator >= FIXED_DT && steps < MAX_STEPS) {
      physicsStep(FIXED_DT);
      accumulator -= FIXED_DT;
      steps++;
    }

    draw();
    animationId = requestAnimationFrame(loop);
  }

  // ======== EVENTOS ========
  startBtn.addEventListener("click", start);
  resetBtn.addEventListener("click", resetAll);
  pauseBtn.addEventListener("click", togglePause);

  playersInput.addEventListener("change", () => {
    playersInput.value = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    if (!running) resetAll();
  });

  heightInput.addEventListener("change", () => {
    heightInput.value = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    if (!running) resetAll();
  });

  namesListEl.addEventListener("input", () => {
    if (!running) syncPlayersInputFromNames();
  });
  namesListEl.addEventListener("paste", () => {
    setTimeout(() => { if (!running) syncPlayersInputFromNames(); }, 0);
  });

  window.addEventListener("resize", () => {
    fitPanelHeight();
    setCanvasSizeOnly();
  });

  // ======== INIT ========
  function init() {
    fitPanelHeight();
    setCanvasSizeOnly();
    syncPlayersInputFromNames();
    resetAll();
  }
  init();
})();
</script>
</body>
</html>
