<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bomb Plink Furras - Sorteio</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0f14; color:#e9eef5;
      display:flex; flex-direction:column; min-height:100vh;
      overscroll-behavior: none;
    }
    header{
      padding:14px 16px; border-bottom:1px solid #1b2633;
      display:flex; align-items:center; gap:14px; flex-wrap:wrap;
    }
    header .group{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    input[type="number"], textarea, input[type="range"]{
      padding:8px 10px; border:1px solid #243447; border-radius:10px;
      background:#0f1620; color:#e9eef5; outline:none;
      font-family: inherit;
      font-size:16px;
    }
    input[type="number"]{ width:92px; }
    label{ color:#cfe0f7; font-size:13px; }
    button{
      padding:9px 12px; border:1px solid #2a3c52; border-radius:12px;
      background:#101a26; color:#e9eef5; cursor:pointer;
      font-size:16px;
    }
    button:hover{ background:#132033; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .hint{ color:#b7c3d4; font-size:13px; }
    main{
      display:grid; grid-template-columns: 1fr 360px; gap:12px;
      padding:12px; flex:1;
    }
    .panel{
      border:1px solid #1b2633; border-radius:14px; background:#0f1620;
      overflow:hidden;
    }
    #canvasWrap{ position:relative; }
    canvas{ width:100%; height:100%; display:block; background: radial-gradient(1200px 600px at 50% 15%, #0f2034, #070b10); }

    .side{ padding:12px; display:flex; flex-direction:column; gap:12px; }
    .card{
      border:1px solid #1b2633; border-radius:14px; background:#0b111a;
      padding:12px;
    }
    h3{ margin:0 0 8px 0; font-size:14px; color:#cfe0f7; }
    .small{ font-size:12px; color:#b7c3d4; line-height:1.35; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    ol{ margin:0; padding-left:20px; }
    li{ margin:6px 0; }
    .badge{
      display:inline-block; min-width:22px; padding:2px 8px; border-radius:999px;
      border:1px solid #2a3c52; background:#0f1620; margin-left:8px; font-size:12px; color:#b7c3d4;
    }
    textarea{
      width:100%;
      min-height: 220px;
      resize: vertical;
      line-height: 1.35;
      white-space: pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:16px;
    }
    .sliderRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
    }
    input[type="range"]{
      width:100%;
      padding:6px 10px;
    }
    .pill{
      border:1px solid #2a3c52;
      background:#0f1620;
      border-radius:999px;
      padding:4px 10px;
      font-size:12px;
      color:#cfe0f7;
      min-width:70px;
      text-align:center;
      user-select:none;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      textarea{ min-height: 180px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <strong>Sorteio com Bolinhas</strong>
      <span class="hint">Defina jogadores (2‚Äì20), cole nomes, altura e % de bombas.</span>
    </div>

    <div class="group" style="margin-left:auto;">
      <label for="players">Jogadores:</label>
      <input id="players" type="number" min="2" max="20" value="8" />

      <label for="heightPx">Altura (px):</label>
      <input id="heightPx" type="number" min="1200" max="8000" value="3600" />

      <button id="startBtn">Iniciar</button>
      <button id="resetBtn">Resetar</button>
      <button id="pauseBtn" disabled>Pausar</button>
    </div>
  </header>

  <main>
    <div class="panel" id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="panel side">
      <div class="card">
        <div class="row">
          <h3>Lista de nomes (1 por linha)</h3>
          <span class="small">Ctrl+V</span>
        </div>
        <textarea id="namesList" placeholder="Cole aqui (um por linha), por exemplo:
Ana
Bruno
Carla
Diego"></textarea>
        <div class="small" style="margin-top:10px;">
          O jogo usa os <strong>primeiros N nomes</strong>, onde <strong>N</strong> √© o n√∫mero de jogadores.
          Se faltar nome, completa com ‚ÄúJogador X‚Äù. Se sobrar, ignora o excedente.
        </div>
      </div>

      <div class="card">
        <div class="row">
          <h3>Bombas (üí£)</h3>
          <span class="small">at√© 20%</span>
        </div>

        <div class="sliderRow">
          <input id="bombRate" type="range" min="0" max="20" step="1" value="10" />
          <div class="pill" id="bombRateLabel">10%</div>
        </div>

        <div class="small" style="margin-top:10px;">
          Ajuste a porcentagem e clique em <strong>Resetar</strong> (ou <strong>Iniciar</strong>) para gerar um novo tabuleiro.
          Durante o sorteio, o slider fica travado para n√£o mudar o tabuleiro no meio.
        </div>
      </div>

      <div class="card">
        <div class="row">
          <h3>Ranking</h3>
          <span class="small">chegada e desclassificados</span>
        </div>
        <ol id="ranking"></ol>
      </div>
    </div>
  </main>

<script>
(() => {
  // =========================
  // Mundo fixo (evita bugs no mobile/zoom)
  // =========================
  const SIM_W = 900;
  const WALL_PADDING = 14;

  // ======== F√çSICA ========
  const GRAVITY = 1500;
  const AIR_DRAG = 0.995;
  const BOUNCE = 0.78;

  const PEG_RADIUS = 6;
  const BALL_RADIUS = 14;
  const FINISH_BAND = 64;

  // Randomicidade
  const RANDOM_KICK = 180;
  const SIDE_NOISE = 40;

  // Anti-stuck
  const UNSTUCK_TIME = 0.22;
  const UNSTUCK_SPEED = 55;
  const UNSTUCK_PUSH_X = 520;
  const UNSTUCK_PUSH_UP = 240;

  // Estabilidade
  const FIXED_DT = 1/120;
  const MAX_ACCUM = 0.12;
  const MAX_STEPS = 10;

  // Limites de velocidade (evita ‚Äút√∫nel‚Äù nas paredes)
  const MAX_VX = 2200;
  const MAX_VY = 4200;

  // Bombas
  const BOMB_RADIUS = 10;
  let bombRate = 0.10; // (0..0.20) controlado pelo slider

  // ======== DOM ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const playersInput = document.getElementById('players');
  const heightInput = document.getElementById('heightPx');
  const namesListEl = document.getElementById('namesList');

  const bombRateEl = document.getElementById('bombRate');
  const bombRateLabel = document.getElementById('bombRateLabel');

  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const rankingEl = document.getElementById('ranking');

  // ======== ESTADO ========
  let DPR = 1;
  let CSS_W = 900, CSS_H = 560;
  let SCALE = 1;
  let VIEW_H_WORLD = 560;

  let WORLD_H = 3600;

  let obstacles = []; // {x,y,r,type:'peg'|'bomb'}
  let balls = [];

  let running = false;
  let paused = false;

  let finishOrder = []; // {id,name,t,status:'chegou'|'desclassificado'}
  let animationId = null;

  let cameraY = 0;
  let cameraTargetY = 0;

  let lastT = 0;
  let startTime = 0;
  let accumulator = 0;

  // ======== HELPERS ========
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const now = () => performance.now();

  function distinctColor(i, n){
    const h = (i * (360 / n)) % 360;
    return `hsl(${h} 80% 60%)`;
  }

  function parseNames() {
    return (namesListEl.value || "")
      .split(/\r?\n/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  // ======== CANVAS / SCALE ========
  function fitPanelHeight(){
    const wrap = document.getElementById("canvasWrap");
    const headerH = document.querySelector("header").getBoundingClientRect().height;
    const target = Math.max(420, window.innerHeight - headerH - 24);
    wrap.style.height = target + "px";
  }

  function setCanvasSizeOnly() {
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();

    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    CSS_W = Math.floor(rect.width);
    CSS_H = Math.floor(Math.max(420, rect.height));

    canvas.width  = CSS_W * DPR;
    canvas.height = CSS_H * DPR;
    canvas.style.width = CSS_W + "px";
    canvas.style.height = CSS_H + "px";

    SCALE = CSS_W / SIM_W;
    VIEW_H_WORLD = CSS_H / SCALE;

    cameraY = clamp(cameraY, 0, Math.max(0, WORLD_H - VIEW_H_WORLD));
    cameraTargetY = cameraY;

    draw();
  }

  // ======== TABULEIRO ========
  function buildBoard() {
    obstacles = [];

    const topMargin = 90;
    const bottomMargin = FINISH_BAND + 120;
    const usableH = WORLD_H - topMargin - bottomMargin;

    const cols = 12;
    const colGap = (SIM_W - 2 * WALL_PADDING) / cols;

    const rowGapTarget = 54;
    const rows = Math.floor(clamp(usableH / rowGapTarget, 18, 120));
    const rowGap = usableH / rows;

    for (let r = 0; r < rows; r++) {
      const y = topMargin + r * rowGap + 20;
      const offset = (r % 2) * (colGap / 2);

      for (let c = 0; c <= cols; c++) {
        const x = WALL_PADDING + c * colGap + offset;
        if (x < WALL_PADDING + 18 || x > SIM_W - WALL_PADDING - 18) continue;

        const isBomb = (Math.random() < bombRate);
        obstacles.push({
          x, y,
          type: isBomb ? 'bomb' : 'peg',
          r: isBomb ? BOMB_RADIUS : PEG_RADIUS
        });
      }
    }
  }

  function createBalls(n) {
    balls = [];
    finishOrder = [];
    rankingEl.innerHTML = "";

    cameraY = 0;
    cameraTargetY = 0;

    const names = parseNames();
    const topY = 50;
    const gap = (SIM_W - 2 * WALL_PADDING) / (n + 1);

    for (let i = 0; i < n; i++) {
      const id = i + 1;
      const x = WALL_PADDING + (i + 1) * gap;
      const name = (names[i] || `Jogador ${id}`).trim() || `Jogador ${id}`;

      balls.push({
        id,
        name,
        x, y: topY,
        vx: rand(-70, 70),
        vy: rand(-20, 20),
        r: BALL_RADIUS,
        color: distinctColor(i, n),
        finished: false,
        eliminated: false,
        finishT: null,

        lastX: x,
        lastY: topY,
        stuck: 0
      });
    }
  }

  function setControlsEnabled(enabled) {
    playersInput.disabled = !enabled;
    heightInput.disabled = !enabled;
    namesListEl.disabled = !enabled;

    // slider tamb√©m
    bombRateEl.disabled = !enabled;
  }

  function resetAll() {
    running = false;
    paused = false;

    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    accumulator = 0;

    const n = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    playersInput.value = n;

    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    // aplica slider -> bombRate
    const br = clamp(parseInt(bombRateEl.value || "10", 10), 0, 20);
    bombRateEl.value = br;
    bombRateLabel.textContent = `${br}%`;
    bombRate = br / 100;

    buildBoard();
    createBalls(n);

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    pauseBtn.textContent = "Pausar";
    setControlsEnabled(true);

    cameraY = 0;
    cameraTargetY = 0;

    draw();
  }

  function start() {
    const n = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    playersInput.value = n;

    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    // fixa bombRate a partir do slider no momento do start
    const br = clamp(parseInt(bombRateEl.value || "10", 10), 0, 20);
    bombRateEl.value = br;
    bombRateLabel.textContent = `${br}%`;
    bombRate = br / 100;

    buildBoard();
    createBalls(n);

    running = true;
    paused = false;

    accumulator = 0;
    lastT = now();
    startTime = lastT;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = "Pausar";
    setControlsEnabled(false);

    loop();
  }

  function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Continuar" : "Pausar";
    if (!paused) {
      lastT = now();
      loop();
    }
  }

  // ======== PAREDES (robusto) ========
  function enforceWalls(b) {
    const left = WALL_PADDING + b.r;
    const right = SIM_W - WALL_PADDING - b.r;

    if (b.x < left)  { b.x = left;  b.vx = Math.abs(b.vx) * BOUNCE; }
    if (b.x > right) { b.x = right; b.vx = -Math.abs(b.vx) * BOUNCE; }

    b.x = clamp(b.x, left, right);
  }

  // ======== COLIS√ïES ========
  function collideBallWithPeg(b, o) {
    const dx = b.x - o.x;
    const dy = b.y - o.y;
    const dist = Math.hypot(dx, dy);
    const minDist = b.r + o.r;
    if (dist >= minDist || dist === 0) return false;

    const nx = dx / dist;
    const ny = dy / dist;

    const overlap = (minDist - dist);
    b.x += nx * overlap;
    b.y += ny * overlap;

    const vn = b.vx * nx + b.vy * ny;
    if (vn < 0) {
      b.vx -= (1 + BOUNCE) * vn * nx;
      b.vy -= (1 + BOUNCE) * vn * ny;
    }

    b.vx += rand(-RANDOM_KICK, RANDOM_KICK) * 0.12;
    return true;
  }

  function collideBalls(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = a.r + b.r;
    if (dist >= minDist || dist === 0) return;

    const nx = dx / dist;
    const ny = dy / dist;
    const overlap = minDist - dist;

    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;

    const dvx = b.vx - a.vx;
    const dvy = b.vy - a.vy;
    const vn = dvx * nx + dvy * ny;
    if (vn > 0) return;

    const impulse = -(1 + 0.65) * vn / 2;
    a.vx -= impulse * nx;
    a.vy -= impulse * ny;
    b.vx += impulse * nx;
    b.vy += impulse * ny;
  }

  function disqualify(b, reason) {
    if (b.finished || b.eliminated) return;

    b.eliminated = true;
    b.finished = true;
    b.finishT = (now() - startTime) / 1000;

    b.x = -9999; b.y = -9999;
    b.vx = 0; b.vy = 0;

    finishOrder.push({ id: b.id, name: b.name, t: b.finishT, status: 'desclassificado', reason });
    updateRanking();
  }

  // ======== SIMULA√á√ÉO ========
  function physicsStep(dt) {
    const finishLineY = WORLD_H - FINISH_BAND;
    const bottom = WORLD_H - 6;

    for (const b of balls) {
      if (b.finished) continue;

      b.vy += GRAVITY * dt;
      b.vx += (rand(-SIDE_NOISE, SIDE_NOISE)) * dt;

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      const drag = Math.pow(AIR_DRAG, dt * 60);
      b.vx *= drag;
      b.vy *= drag;

      b.vx = clamp(b.vx, -MAX_VX, MAX_VX);
      b.vy = clamp(b.vy, -MAX_VY, MAX_VY);

      const top = 12 + b.r;
      if (b.y < top) { b.y = top; b.vy = Math.abs(b.vy) * BOUNCE; }

      // paredes antes
      enforceWalls(b);

      // obst√°culos
      for (const o of obstacles) {
        if (b.finished) break;

        if (o.type === 'bomb') {
          const dx = b.x - o.x;
          const dy = b.y - o.y;
          const dist = Math.hypot(dx, dy);
          if (dist < (b.r + o.r)) {
            disqualify(b, 'bomba');
            break;
          }
        } else {
          collideBallWithPeg(b, o);
        }
      }

      if (b.finished) continue;

      // paredes depois (corrige empurr√µes laterais)
      enforceWalls(b);

      // chegada
      if (b.y >= finishLineY - b.r - 2) {
        b.finished = true;
        b.finishT = (performance.now() - startTime) / 1000;

        b.x = clamp(b.x, WALL_PADDING + b.r, SIM_W - WALL_PADDING - b.r);
        b.y = finishLineY + FINISH_BAND * 0.5;
        b.vx = 0; b.vy = 0;

        finishOrder.push({ id: b.id, name: b.name, t: b.finishT, status: 'chegou' });
        updateRanking();
        continue;
      }

      if (b.y > bottom - b.r) {
        b.y = bottom - b.r;
        b.vy = -Math.abs(b.vy) * 0.35;
        b.vx *= 0.92;
      }

      // anti-stuck
      const speed = Math.hypot(b.vx, b.vy);
      const moved = Math.hypot(b.x - b.lastX, b.y - b.lastY);

      if (speed < UNSTUCK_SPEED && moved < 0.35) {
        b.stuck += dt;
        if (b.stuck > UNSTUCK_TIME) {
          b.vx += rand(-UNSTUCK_PUSH_X, UNSTUCK_PUSH_X);
          b.vy -= rand(0, UNSTUCK_PUSH_UP);
          b.vx = clamp(b.vx, -MAX_VX, MAX_VX);
          b.vy = clamp(b.vy, -MAX_VY, MAX_VY);
          b.stuck = 0;
          enforceWalls(b);
        }
      } else {
        b.stuck = 0;
      }

      b.lastX = b.x;
      b.lastY = b.y;
    }

    for (let i = 0; i < balls.length; i++){
      for (let j = i + 1; j < balls.length; j++){
        if (balls[i].finished || balls[j].finished) continue;
        collideBalls(balls[i], balls[j]);
        enforceWalls(balls[i]);
        enforceWalls(balls[j]);
      }
    }

    const active = balls.filter(b => !b.finished);
    const yFocus = active.length ? Math.max(...active.map(b => b.y)) : (WORLD_H - FINISH_BAND);
    const desired = clamp(yFocus - VIEW_H_WORLD * 0.35, 0, Math.max(0, WORLD_H - VIEW_H_WORLD));
    cameraTargetY = desired;
    cameraY += (cameraTargetY - cameraY) * 0.12;

    if (finishOrder.length === balls.length) {
      running = false;
      pauseBtn.disabled = true;
      startBtn.disabled = false;
      setControlsEnabled(true);
    }
  }

  // ======== RENDER ========
  function drawBoardWorld() {
    const finishY = WORLD_H - FINISH_BAND;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.07)";
    ctx.fillRect(0, finishY, SIM_W, FINISH_BAND);

    ctx.fillStyle = "rgba(255,255,255,0.40)";
    ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("LINHA DE CHEGADA", 14, finishY + 20);
    ctx.restore();

    for (const o of obstacles) {
      if (o.type === 'peg') {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r + 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillText("üí£", o.x, o.y + 0.5);
        ctx.restore();
      }
    }

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(WALL_PADDING, 0);
    ctx.lineTo(WALL_PADDING, WORLD_H);
    ctx.moveTo(SIM_W - WALL_PADDING, 0);
    ctx.lineTo(SIM_W - WALL_PADDING, WORLD_H);
    ctx.stroke();
    ctx.restore();
  }

  function drawBallsWorld() {
    for (const b of balls) {
      if (b.eliminated) continue;

      ctx.save();
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fillStyle = b.color;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(b.id), b.x, b.y);

      const name = b.name || `Jogador ${b.id}`;
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.strokeText(name, b.x, b.y - b.r - 10);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillText(name, b.x, b.y - b.r - 10);
      ctx.restore();
    }
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const status = running ? (paused ? "PAUSADO" : "RODANDO") : "PRONTO";

    const maxCam = Math.max(0, WORLD_H - VIEW_H_WORLD);
    const pct = maxCam === 0 ? 100 : (cameraY / maxCam * 100);
    ctx.fillText(`Status: ${status}`, 14, 18);
    ctx.fillText(`Bombas: ${(bombRate*100).toFixed(0)}% | Queda: ${WORLD_H}px | C√¢mera: ${pct.toFixed(0)}%`, 14, 36);
    ctx.restore();
  }

  function draw() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.setTransform(DPR * SCALE, 0, 0, DPR * SCALE, 0, 0);
    ctx.save();
    ctx.translate(0, -cameraY);
    drawBoardWorld();
    drawBallsWorld();
    ctx.restore();

    ctx.setTransform(DPR,0,0,DPR,0,0);
    drawHUD();
  }

  function updateRanking() {
    const sorted = [...finishOrder].sort((a,b) => a.t - b.t);
    rankingEl.innerHTML = "";

    for (const item of sorted) {
      const li = document.createElement("li");
      li.textContent = (item.status === 'desclassificado')
        ? `${item.name} ‚Äî DESCLASSIFICADO`
        : item.name;

      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = `${item.t.toFixed(2)}s`;
      li.appendChild(badge);

      rankingEl.appendChild(li);
    }
  }

  // ======== LOOP ========
  function loop() {
    if (!running || paused) { draw(); return; }

    const t = now();
    let dt = (t - lastT) / 1000;
    lastT = t;

    dt = clamp(dt, 0, MAX_ACCUM);
    accumulator += dt;

    let steps = 0;
    while (accumulator >= FIXED_DT && steps < MAX_STEPS) {
      physicsStep(FIXED_DT);
      accumulator -= FIXED_DT;
      steps++;
    }

    draw();
    animationId = requestAnimationFrame(loop);
  }

  // ======== SLIDER: atualiza label em tempo real ========
  function syncBombUI() {
    const br = clamp(parseInt(bombRateEl.value || "10", 10), 0, 20);
    bombRateEl.value = br;
    bombRateLabel.textContent = `${br}%`;
    // bombRate s√≥ √© aplicado no Reset/Iniciar (para manter tabuleiro consistente)
  }
  bombRateEl.addEventListener("input", syncBombUI);
  bombRateEl.addEventListener("change", syncBombUI);

  // ======== EVENTOS ========
  startBtn.addEventListener("click", start);
  resetBtn.addEventListener("click", resetAll);
  pauseBtn.addEventListener("click", togglePause);

  playersInput.addEventListener("change", () => {
    playersInput.value = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    if (!running) resetAll();
  });

  heightInput.addEventListener("change", () => {
    heightInput.value = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    if (!running) resetAll();
  });

  window.addEventListener("resize", () => {
    fitPanelHeight();
    setCanvasSizeOnly();
  });

  // ======== INIT ========
  function init() {
    syncBombUI();
    fitPanelHeight();
    setCanvasSizeOnly();
    resetAll();
  }
  init();
})();
</script>
</body>
</html>
