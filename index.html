<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Plinko Furras Sorteio </title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0f14; color:#e9eef5;
      display:flex; flex-direction:column; min-height:100vh;
    }
    header{
      padding:14px 16px; border-bottom:1px solid #1b2633;
      display:flex; align-items:center; gap:14px; flex-wrap:wrap;
    }
    header .group{ display:flex; align-items:center; gap:10px; }
    input[type="number"]{
      width:84px; padding:8px 10px; border:1px solid #243447; border-radius:10px;
      background:#0f1620; color:#e9eef5; outline:none;
    }
    button{
      padding:9px 12px; border:1px solid #2a3c52; border-radius:12px;
      background:#101a26; color:#e9eef5; cursor:pointer;
    }
    button:hover{ background:#132033; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .hint{ color:#b7c3d4; font-size:13px; }
    main{
      display:grid; grid-template-columns: 1fr 320px; gap:12px;
      padding:12px; flex:1;
    }
    .panel{
      border:1px solid #1b2633; border-radius:14px; background:#0f1620;
      overflow:hidden;
    }
    #canvasWrap{ position:relative; }
    canvas{ width:100%; height:100%; display:block; background: radial-gradient(1200px 600px at 50% 15%, #0f2034, #070b10); }
    .side{
      padding:12px;
      display:flex; flex-direction:column; gap:12px;
    }
    .card{
      border:1px solid #1b2633; border-radius:14px; background:#0b111a;
      padding:12px;
    }
    h3{ margin:0 0 8px 0; font-size:14px; color:#cfe0f7; }
    ol{ margin:0; padding-left:20px; }
    li{ margin:6px 0; }
    .badge{
      display:inline-block; min-width:22px; padding:2px 8px; border-radius:999px;
      border:1px solid #2a3c52; background:#0f1620; margin-left:8px; font-size:12px; color:#b7c3d4;
    }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .small{ font-size:12px; color:#b7c3d4; }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <strong>Sorteio com Bolinhas</strong>
      <span class="hint">Defina jogadores (2–20) e inicie o sorteio.</span>
    </div>

    <div class="group" style="margin-left:auto;">
      <label for="players">Jogadores:</label>
      <input id="players" type="number" min="2" max="20" value="8" />
      <button id="startBtn">Iniciar</button>
      <button id="resetBtn">Resetar</button>
      <button id="pauseBtn" disabled>Pausar</button>
    </div>
  </header>

  <main>
    <div class="panel" id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="panel side">
      <div class="card">
        <div class="row">
          <h3>Ranking (ordem de chegada)</h3>
          <div class="small">Linha de chegada: faixa inferior</div>
        </div>
        <ol id="ranking"></ol>
      </div>

      <div class="card">
        <h3>Como funciona</h3>
        <div class="small">
          As bolinhas (uma por jogador) caem com gravidade e batem nos pinos, desviando
          aleatoriamente. O vencedor é quem cruza a linha de chegada primeiro.
        </div>
        <div class="small" style="margin-top:10px;">
          Dica: você pode ajustar a “aleatoriedade” mudando a constante <code>RANDOM_KICK</code> no script.
        </div>
      </div>
    </div>
  </main>

<script>
(() => {
  // ======== CONFIGURAÇÕES ========
  const GRAVITY = 1400;          // px/s^2
  const AIR_DRAG = 0.995;        // arrasto (0..1)
  const BOUNCE = 0.78;           // restituição nas colisões
  const RANDOM_KICK = 120;       // "chute" lateral aleatório em colisões (px/s)
  const PEG_RADIUS = 6;
  const BALL_RADIUS = 14;
  const FINISH_BAND = 48;        // altura da faixa de chegada
  const WALL_PADDING = 14;

  // ======== DOM ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const playersInput = document.getElementById('players');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const rankingEl = document.getElementById('ranking');

  // ======== ESTADO ========
  let W = 900, H = 560, DPR = 1;
  let pegs = [];
  let balls = [];
  let running = false;
  let paused = false;
  let lastT = 0;
  let startTime = 0;
  let finishOrder = []; // [{id, t}]
  let animationId = null;

  // ======== HELPERS ========
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const now = () => performance.now();

  function setCanvasSize() {
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();
    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    W = Math.floor(rect.width);
    H = Math.floor(Math.max(420, rect.height)); // garante um mínimo

    canvas.width  = W * DPR;
    canvas.height = H * DPR;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    buildBoard();
    draw();
  }

  function distinctColor(i, n){
    const h = (i * (360 / n)) % 360;
    return `hsl(${h} 80% 60%)`;
  }

  function buildBoard() {
    pegs = [];

    const topMargin = 70;
    const bottomMargin = FINISH_BAND + 40;
    const usableH = H - topMargin - bottomMargin;

    // Distribuição de pinos (estilo Plinko)
    const rows = Math.floor(clamp(usableH / 46, 7, 12));
    const cols = Math.floor(clamp(W / 70, 8, 16));

    const rowGap = usableH / rows;
    const colGap = (W - 2 * WALL_PADDING) / cols;

    for (let r = 0; r < rows; r++) {
      const y = topMargin + r * rowGap + 20;
      const offset = (r % 2) * (colGap / 2);

      for (let c = 0; c <= cols; c++) {
        const x = WALL_PADDING + c * colGap + offset;

        // evita pinos muito colados na parede
        if (x < WALL_PADDING + 18 || x > W - WALL_PADDING - 18) continue;

        pegs.push({ x, y, r: PEG_RADIUS });
      }
    }
  }

  function createBalls(n) {
    balls = [];
    finishOrder = [];
    rankingEl.innerHTML = "";

    // cria bolas distribuídas no topo
    const topY = 40;
    const gap = (W - 2 * WALL_PADDING) / (n + 1);

    for (let i = 0; i < n; i++) {
      const x = WALL_PADDING + (i + 1) * gap;

      balls.push({
        id: i + 1,
        x, y: topY,
        vx: rand(-60, 60),
        vy: rand(-20, 20),
        r: BALL_RADIUS,
        color: distinctColor(i, n),
        finished: false,
        finishT: null
      });
    }
  }

  function resetAll() {
    running = false;
    paused = false;
    lastT = 0;
    startTime = 0;
    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    const n = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    playersInput.value = n;
    createBalls(n);

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    pauseBtn.textContent = "Pausar";
    draw();
  }

  function start() {
    const n = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    playersInput.value = n;

    createBalls(n);
    running = true;
    paused = false;
    lastT = now();
    startTime = lastT;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = "Pausar";

    loop();
  }

  function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Continuar" : "Pausar";
    if (!paused) {
      lastT = now();
      loop();
    }
  }

  // ======== FÍSICA ========
  function collideBallWithPeg(b, p) {
    const dx = b.x - p.x;
    const dy = b.y - p.y;
    const dist = Math.hypot(dx, dy);
    const minDist = b.r + p.r;

    if (dist >= minDist || dist === 0) return;

    // normal
    const nx = dx / dist;
    const ny = dy / dist;

    // empurra para fora
    const overlap = (minDist - dist);
    b.x += nx * overlap;
    b.y += ny * overlap;

    // reflete velocidade na normal
    const vn = b.vx * nx + b.vy * ny;
    if (vn < 0) {
      b.vx -= (1 + BOUNCE) * vn * nx;
      b.vy -= (1 + BOUNCE) * vn * ny;
    }

    // pequeno "chute" aleatório para dar imprevisibilidade
    b.vx += rand(-RANDOM_KICK, RANDOM_KICK) * 0.12;
  }

  function collideBalls(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = a.r + b.r;
    if (dist >= minDist || dist === 0) return;

    // separa
    const nx = dx / dist;
    const ny = dy / dist;
    const overlap = minDist - dist;

    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;

    // colisão elástica simplificada (mesma massa)
    const dvx = b.vx - a.vx;
    const dvy = b.vy - a.vy;
    const vn = dvx * nx + dvy * ny;
    if (vn > 0) return;

    const impulse = -(1 + 0.65) * vn / 2;
    a.vx -= impulse * nx;
    a.vy -= impulse * ny;
    b.vx += impulse * nx;
    b.vy += impulse * ny;
  }

  function step(dt) {
    // dt em segundos
    const floorY = H - FINISH_BAND - 6;

    for (const b of balls) {
      if (b.finished) continue;

      // gravidade
      b.vy += GRAVITY * dt;

      // integra
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // arrasto
      b.vx *= Math.pow(AIR_DRAG, dt * 60);
      b.vy *= Math.pow(AIR_DRAG, dt * 60);

      // paredes
      const left = WALL_PADDING + b.r;
      const right = W - WALL_PADDING - b.r;

      if (b.x < left) { b.x = left; b.vx = Math.abs(b.vx) * BOUNCE; }
      if (b.x > right){ b.x = right; b.vx = -Math.abs(b.vx) * BOUNCE; }

      // teto (só para não ficar preso)
      const top = 12 + b.r;
      if (b.y < top) { b.y = top; b.vy = Math.abs(b.vy) * BOUNCE; }

      // chão de física (antes da faixa de chegada)
      if (b.y > floorY - b.r) {
        b.y = floorY - b.r;
        b.vy = -Math.abs(b.vy) * 0.35; // amortecimento forte no chão
        b.vx *= 0.92;
      }

      // colisão com pinos
      for (const p of pegs) collideBallWithPeg(b, p);

      // colisão entre bolas (até 20, OK)
      // (feito em segundo loop para reduzir viés)
    }

    for (let i = 0; i < balls.length; i++){
      for (let j = i + 1; j < balls.length; j++){
        if (balls[i].finished || balls[j].finished) continue;
        collideBalls(balls[i], balls[j]);
      }
    }

    // verifica chegadas
    const finishLineY = H - FINISH_BAND;
    for (const b of balls) {
      if (b.finished) continue;
      if (b.y >= finishLineY - b.r - 2) {
        b.finished = true;
        b.finishT = (now() - startTime) / 1000;
        finishOrder.push({ id: b.id, t: b.finishT });
        updateRanking();
      }
    }

    // se todos terminaram, para
    if (finishOrder.length === balls.length) {
      running = false;
      pauseBtn.disabled = true;
      startBtn.disabled = false;
    }
  }

  // ======== RENDER ========
  function draw() {
    ctx.clearRect(0, 0, W, H);

    // faixa de chegada
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(0, H - FINISH_BAND, W, FINISH_BAND);
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("LINHA DE CHEGADA", 14, H - FINISH_BAND + 20);
    ctx.restore();

    // pinos
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    for (const p of pegs) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // paredes (só visual)
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(WALL_PADDING, 0);
    ctx.lineTo(WALL_PADDING, H);
    ctx.moveTo(W - WALL_PADDING, 0);
    ctx.lineTo(W - WALL_PADDING, H);
    ctx.stroke();
    ctx.restore();

    // bolas
    for (const b of balls) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fillStyle = b.color;
      ctx.fill();

      // brilho
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();

      // número
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(b.id), b.x, b.y);
      ctx.restore();
    }

    // status
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const status = running ? (paused ? "PAUSADO" : "RODANDO") : "PRONTO";
    ctx.fillText(`Status: ${status}`, 14, 18);
    ctx.restore();
  }

  function updateRanking() {
    // ordena por tempo (menor = primeiro)
    const sorted = [...finishOrder].sort((a,b) => a.t - b.t);

    rankingEl.innerHTML = "";
    for (const item of sorted) {
      const li = document.createElement("li");
      li.textContent = `Jogador ${item.id}`;
      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = `${item.t.toFixed(2)}s`;
      li.appendChild(badge);
      rankingEl.appendChild(li);
    }
  }

  // ======== LOOP ========
  function loop() {
    if (!running || paused) { draw(); return; }

    const t = now();
    let dt = (t - lastT) / 1000;
    lastT = t;

    // evita "pulos" grandes (ex: aba em segundo plano)
    dt = clamp(dt, 0, 0.022);

    step(dt);
    draw();

    animationId = requestAnimationFrame(loop);
  }

  // ======== EVENTOS ========
  startBtn.addEventListener("click", start);
  resetBtn.addEventListener("click", resetAll);
  pauseBtn.addEventListener("click", togglePause);

  playersInput.addEventListener("change", () => {
    playersInput.value = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    if (!running) resetAll();
  });

  window.addEventListener("resize", () => setCanvasSize());

  // ======== INIT ========
  // ajusta altura do painel conforme viewport
  function fitPanelHeight(){
    const wrap = document.getElementById("canvasWrap");
    // altura aproximada considerando header
    const headerH = document.querySelector("header").getBoundingClientRect().height;
    const target = Math.max(420, window.innerHeight - headerH - 24);
    wrap.style.height = target + "px";
  }

  fitPanelHeight();
  setCanvasSize();
  resetAll();
})();
</script>
</body>
</html>
