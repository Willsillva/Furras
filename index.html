<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sorteio com Bolinhas (Plinko) — Lista de Nomes</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0f14; color:#e9eef5;
      display:flex; flex-direction:column; min-height:100vh;
    }
    header{
      padding:14px 16px; border-bottom:1px solid #1b2633;
      display:flex; align-items:center; gap:14px; flex-wrap:wrap;
    }
    header .group{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    input[type="number"], input[type="text"], textarea{
      padding:8px 10px; border:1px solid #243447; border-radius:10px;
      background:#0f1620; color:#e9eef5; outline:none;
      font-family: inherit;
    }
    input[type="number"]{ width:92px; }
    label{ color:#cfe0f7; font-size:13px; }
    button{
      padding:9px 12px; border:1px solid #2a3c52; border-radius:12px;
      background:#101a26; color:#e9eef5; cursor:pointer;
    }
    button:hover{ background:#132033; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .hint{ color:#b7c3d4; font-size:13px; }
    main{
      display:grid; grid-template-columns: 1fr 360px; gap:12px;
      padding:12px; flex:1;
    }
    .panel{
      border:1px solid #1b2633; border-radius:14px; background:#0f1620;
      overflow:hidden;
    }
    #canvasWrap{ position:relative; }
    canvas{ width:100%; height:100%; display:block; background: radial-gradient(1200px 600px at 50% 15%, #0f2034, #070b10); }

    .side{ padding:12px; display:flex; flex-direction:column; gap:12px; }
    .card{
      border:1px solid #1b2633; border-radius:14px; background:#0b111a;
      padding:12px;
    }
    h3{ margin:0 0 8px 0; font-size:14px; color:#cfe0f7; }
    .small{ font-size:12px; color:#b7c3d4; line-height:1.35; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    ol{ margin:0; padding-left:20px; }
    li{ margin:6px 0; }
    .badge{
      display:inline-block; min-width:22px; padding:2px 8px; border-radius:999px;
      border:1px solid #2a3c52; background:#0f1620; margin-left:8px; font-size:12px; color:#b7c3d4;
    }
    textarea{
      width:100%;
      min-height: 220px;
      resize: vertical;
      line-height: 1.35;
      white-space: pre;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      textarea{ min-height: 180px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="group">
      <strong>Sorteio com Bolinhas</strong>
      <span class="hint">Defina jogadores (2–20), cole a lista de nomes e a altura da queda.</span>
    </div>

    <div class="group" style="margin-left:auto;">
      <label for="players">Jogadores:</label>
      <input id="players" type="number" min="2" max="20" value="8" />

      <label for="heightPx">Altura (px):</label>
      <input id="heightPx" type="number" min="1200" max="8000" value="3600" />

      <button id="startBtn">Iniciar</button>
      <button id="resetBtn">Resetar</button>
      <button id="pauseBtn" disabled>Pausar</button>
    </div>
  </header>

  <main>
    <div class="panel" id="canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="panel side">
      <div class="card">
        <div class="row">
          <h3>Lista de nomes (1 por linha)</h3>
          <span class="small">Ctrl+V</span>
        </div>

        <textarea id="namesList" class="mono" placeholder="Cole aqui (um por linha), por exemplo:
Ana
Bruno
Carla
Diego"></textarea>

        <div class="small" style="margin-top:10px;">
          O jogo usa os <strong>primeiros N nomes</strong>, onde <strong>N</strong> é o número de jogadores.
          Se faltar nome, completa com “Jogador X”. Se sobrar, ignora o excedente.
        </div>
      </div>

      <div class="card">
        <div class="row">
          <h3>Ordem de chegada (ranking)</h3>
          <span class="small">linha de chegada no final</span>
        </div>
        <ol id="ranking"></ol>
      </div>

      <div class="card">
        <h3>Ajustes rápidos</h3>
        <div class="small">
          Se quiser mais “imprevisibilidade”, aumente <code>RANDOM_KICK</code> no script.
          Se quiser quedas ainda mais longas, aumente o campo <strong>Altura (px)</strong>.
        </div>
      </div>
    </div>
  </main>

<script>
(() => {
  // ======== CONFIGURAÇÕES ========
  const GRAVITY = 1500;          // px/s^2
  const AIR_DRAG = 0.995;        // arrasto (0..1)
  const BOUNCE = 0.78;           // restituição nos pinos/parede
  const RANDOM_KICK = 150;       // “chute” lateral aleatório em colisões (px/s)
  const PEG_RADIUS = 6;
  const BALL_RADIUS = 14;
  const FINISH_BAND = 64;        // faixa visual de chegada
  const WALL_PADDING = 14;

  // ======== DOM ========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const playersInput = document.getElementById('players');
  const heightInput = document.getElementById('heightPx');
  const namesListEl = document.getElementById('namesList');

  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const rankingEl = document.getElementById('ranking');

  // ======== ESTADO ========
  let VIEW_W = 900, VIEW_H = 560, DPR = 1;
  let WORLD_H = 3600;
  let pegs = [];
  let balls = [];

  let running = false;
  let paused = false;
  let lastT = 0;
  let startTime = 0;
  let finishOrder = []; // [{id, name, t}]
  let animationId = null;

  // câmera (para queda longa sem precisar rolar a página)
  let cameraY = 0;
  let cameraTargetY = 0;

  // ======== HELPERS ========
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const now = () => performance.now();

  function distinctColor(i, n){
    const h = (i * (360 / n)) % 360;
    return `hsl(${h} 80% 60%)`;
  }

  function parseNames() {
    // separa por linha, remove espaços, ignora linhas vazias
    return (namesListEl.value || "")
      .split(/\r?\n/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  function setCanvasSize() {
    const wrap = document.getElementById('canvasWrap');
    const rect = wrap.getBoundingClientRect();

    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    VIEW_W = Math.floor(rect.width);
    VIEW_H = Math.floor(Math.max(420, rect.height));

    canvas.width  = VIEW_W * DPR;
    canvas.height = VIEW_H * DPR;
    canvas.style.width = VIEW_W + "px";
    canvas.style.height = VIEW_H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    // Altura do mundo (queda)
    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    buildBoard();
    draw();
  }

  function buildBoard() {
    pegs = [];

    // Margens no mundo
    const topMargin = 90;
    const bottomMargin = FINISH_BAND + 120;
    const usableH = WORLD_H - topMargin - bottomMargin;

    // densidade de pinos
    const rows = Math.floor(clamp(usableH / 50, 16, 80));
    const cols = Math.floor(clamp(VIEW_W / 70, 9, 16));

    const rowGap = usableH / rows;
    const colGap = (VIEW_W - 2 * WALL_PADDING) / cols;

    for (let r = 0; r < rows; r++) {
      const y = topMargin + r * rowGap + 20;
      const offset = (r % 2) * (colGap / 2);

      for (let c = 0; c <= cols; c++) {
        const x = WALL_PADDING + c * colGap + offset;
        if (x < WALL_PADDING + 18 || x > VIEW_W - WALL_PADDING - 18) continue;
        pegs.push({ x, y, r: PEG_RADIUS });
      }
    }
  }

  function createBalls(n) {
    balls = [];
    finishOrder = [];
    rankingEl.innerHTML = "";
    cameraY = 0;
    cameraTargetY = 0;

    const names = parseNames(); // <- AQUI: nomes vindos da lista
    const topY = 50;
    const gap = (VIEW_W - 2 * WALL_PADDING) / (n + 1);

    for (let i = 0; i < n; i++) {
      const id = i + 1;
      const x = WALL_PADDING + (i + 1) * gap;

      const name = (names[i] || `Jogador ${id}`).trim() || `Jogador ${id}`;

      balls.push({
        id,
        name,
        x, y: topY,
        vx: rand(-70, 70),
        vy: rand(-20, 20),
        r: BALL_RADIUS,
        color: distinctColor(i, n),
        finished: false,
        finishT: null
      });
    }
  }

  function setControlsEnabled(enabled) {
    playersInput.disabled = !enabled;
    heightInput.disabled = !enabled;
    namesListEl.disabled = !enabled; // <- só isso foi acrescentado no controle
  }

  function resetAll() {
    running = false;
    paused = false;
    lastT = 0;
    startTime = 0;
    if (animationId) cancelAnimationFrame(animationId);
    animationId = null;

    const n = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    playersInput.value = n;

    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    buildBoard();
    createBalls(n);

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    pauseBtn.textContent = "Pausar";
    setControlsEnabled(true);
    draw();
  }

  function start() {
    const n = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    playersInput.value = n;

    WORLD_H = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    heightInput.value = WORLD_H;

    buildBoard();
    createBalls(n);

    running = true;
    paused = false;
    lastT = now();
    startTime = lastT;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = "Pausar";
    setControlsEnabled(false);

    loop();
  }

  function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Continuar" : "Pausar";
    if (!paused) {
      lastT = now();
      loop();
    }
  }

  // ======== FÍSICA ========
  function collideBallWithPeg(b, p) {
    const dx = b.x - p.x;
    const dy = b.y - p.y;
    const dist = Math.hypot(dx, dy);
    const minDist = b.r + p.r;
    if (dist >= minDist || dist === 0) return;

    const nx = dx / dist;
    const ny = dy / dist;

    // empurra para fora
    const overlap = (minDist - dist);
    b.x += nx * overlap;
    b.y += ny * overlap;

    // reflete velocidade na normal
    const vn = b.vx * nx + b.vy * ny;
    if (vn < 0) {
      b.vx -= (1 + BOUNCE) * vn * nx;
      b.vy -= (1 + BOUNCE) * vn * ny;
    }

    // chute aleatório (imprevisibilidade)
    b.vx += rand(-RANDOM_KICK, RANDOM_KICK) * 0.12;
  }

  function collideBalls(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = a.r + b.r;
    if (dist >= minDist || dist === 0) return;

    const nx = dx / dist;
    const ny = dy / dist;
    const overlap = minDist - dist;

    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;

    // colisão elástica simplificada (mesma massa)
    const dvx = b.vx - a.vx;
    const dvy = b.vy - a.vy;
    const vn = dvx * nx + dvy * ny;
    if (vn > 0) return;

    const impulse = -(1 + 0.65) * vn / 2;
    a.vx -= impulse * nx;
    a.vy -= impulse * ny;
    b.vx += impulse * nx;
    b.vy += impulse * ny;
  }

  function step(dt) {
    const finishLineY = WORLD_H - FINISH_BAND;
    const bottom = WORLD_H - 6;

    for (const b of balls) {
      if (b.finished) continue;

      b.vy += GRAVITY * dt;

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // arrasto
      b.vx *= Math.pow(AIR_DRAG, dt * 60);
      b.vy *= Math.pow(AIR_DRAG, dt * 60);

      // paredes (mundo)
      const left = WALL_PADDING + b.r;
      const right = VIEW_W - WALL_PADDING - b.r;
      if (b.x < left)  { b.x = left;  b.vx = Math.abs(b.vx) * BOUNCE; }
      if (b.x > right) { b.x = right; b.vx = -Math.abs(b.vx) * BOUNCE; }

      // teto
      const top = 12 + b.r;
      if (b.y < top) { b.y = top; b.vy = Math.abs(b.vy) * BOUNCE; }

      // pinos
      for (const p of pegs) collideBallWithPeg(b, p);

      // checagem de chegada (antes do chão final)
      if (b.y >= finishLineY - b.r - 2) {
        b.finished = true;
        b.finishT = (now() - startTime) / 1000;

        // fixa dentro da faixa de chegada
        b.x = clamp(b.x, WALL_PADDING + b.r, VIEW_W - WALL_PADDING - b.r);
        b.y = finishLineY + FINISH_BAND * 0.5;
        b.vx = 0; b.vy = 0;

        finishOrder.push({ id: b.id, name: b.name, t: b.finishT });
        updateRanking();
        continue;
      }

      // chão final (abaixo da linha de chegada)
      if (b.y > bottom - b.r) {
        b.y = bottom - b.r;
        b.vy = -Math.abs(b.vy) * 0.35;
        b.vx *= 0.92;
      }
    }

    // colisão entre bolas
    for (let i = 0; i < balls.length; i++){
      for (let j = i + 1; j < balls.length; j++){
        if (balls[i].finished || balls[j].finished) continue;
        collideBalls(balls[i], balls[j]);
      }
    }

    // câmera: acompanha a(s) bolinha(s) mais adiantada(s)
    const active = balls.filter(b => !b.finished);
    const yFocus = active.length ? Math.max(...active.map(b => b.y)) : (WORLD_H - FINISH_BAND);
    const desired = clamp(yFocus - VIEW_H * 0.35, 0, Math.max(0, WORLD_H - VIEW_H));
    cameraTargetY = desired;
    cameraY += (cameraTargetY - cameraY) * 0.12;

    // finaliza
    if (finishOrder.length === balls.length) {
      running = false;
      pauseBtn.disabled = true;
      startBtn.disabled = false;
      setControlsEnabled(true);
    }
  }

  // ======== RENDER ========
  function drawBoardWorld() {
    // faixa de chegada (no mundo)
    const finishY = WORLD_H - FINISH_BAND;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.07)";
    ctx.fillRect(0, finishY, VIEW_W, FINISH_BAND);

    ctx.fillStyle = "rgba(255,255,255,0.40)";
    ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("LINHA DE CHEGADA", 14, finishY + 20);
    ctx.restore();

    // pinos
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    for (const p of pegs) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // paredes (visual)
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(WALL_PADDING, 0);
    ctx.lineTo(WALL_PADDING, WORLD_H);
    ctx.moveTo(VIEW_W - WALL_PADDING, 0);
    ctx.lineTo(VIEW_W - WALL_PADDING, WORLD_H);
    ctx.stroke();
    ctx.restore();
  }

  function drawBallsWorld() {
    for (const b of balls) {
      // bola
      ctx.save();
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fillStyle = b.color;
      ctx.fill();

      // brilho
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.35, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();

      // número dentro
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(b.id), b.x, b.y);

      // nome acima (durante a queda e também na chegada)
      const name = b.name || `Jogador ${b.id}`;
      ctx.font = "700 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      // contorno para legibilidade
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,0,0,0.75)";
      ctx.strokeText(name, b.x, b.y - b.r - 10);

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillText(name, b.x, b.y - b.r - 10);
      ctx.restore();
    }
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    ctx.font = "600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const status = running ? (paused ? "PAUSADO" : "RODANDO") : "PRONTO";

    const pct = (WORLD_H <= VIEW_H) ? 100 : (cameraY / (WORLD_H - VIEW_H) * 100);
    ctx.fillText(`Status: ${status}`, 14, 18);
    ctx.fillText(`Queda (mundo): ${WORLD_H}px | Câmera: ${pct.toFixed(0)}%`, 14, 36);
    ctx.restore();
  }

  function draw() {
    ctx.clearRect(0, 0, VIEW_W, VIEW_H);

    // desenha o mundo com câmera (translada o y)
    ctx.save();
    ctx.translate(0, -cameraY);
    drawBoardWorld();
    drawBallsWorld();
    ctx.restore();

    // HUD (sem câmera)
    drawHUD();
  }

  function updateRanking() {
    const sorted = [...finishOrder].sort((a,b) => a.t - b.t);

    rankingEl.innerHTML = "";
    for (const item of sorted) {
      const li = document.createElement("li");
      li.textContent = item.name;

      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = `${item.t.toFixed(2)}s`;
      li.appendChild(badge);

      rankingEl.appendChild(li);
    }
  }

  // ======== LOOP ========
  function loop() {
    if (!running || paused) { draw(); return; }

    const t = now();
    let dt = (t - lastT) / 1000;
    lastT = t;

    // limita dt (aba em segundo plano etc.)
    dt = clamp(dt, 0, 0.022);

    step(dt);
    draw();
    animationId = requestAnimationFrame(loop);
  }

  // ======== EVENTOS ========
  startBtn.addEventListener("click", start);
  resetBtn.addEventListener("click", resetAll);
  pauseBtn.addEventListener("click", togglePause);

  playersInput.addEventListener("change", () => {
    playersInput.value = clamp(parseInt(playersInput.value || "8", 10), 2, 20);
    if (!running) resetAll();
  });

  heightInput.addEventListener("change", () => {
    heightInput.value = clamp(parseInt(heightInput.value || "3600", 10), 1200, 8000);
    if (!running) resetAll();
  });

  window.addEventListener("resize", () => {
    fitPanelHeight();
    setCanvasSize();
    if (!running) resetAll();
  });

  // ======== INIT ========
  function fitPanelHeight(){
    const wrap = document.getElementById("canvasWrap");
    const headerH = document.querySelector("header").getBoundingClientRect().height;
    const target = Math.max(420, window.innerHeight - headerH - 24);
    wrap.style.height = target + "px";
  }

  fitPanelHeight();
  setCanvasSize();
  resetAll();
})();
</script>
</body>
</html>
